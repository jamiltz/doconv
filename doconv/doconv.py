#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""doconv

Usage:
  doconv [options] <file> <input_format> <output_format>
  doconv (-h | --help)

Options:
  -o --out-file=<of>  File generated as output of the conversion.
  -v --verbose        Show additional information.
  -h --help           Show this screen.
  --version           Show version.

"""

from collections import namedtuple
from docopt import docopt
from stevedore import extension
from networkx import nx
from os import path
import sys
import os
import shutil
import logging
# doconv imports
from . import log
from .exceptions import UnsatisfiedDependencyException
from .util import append_random_suffix, get_version

global logger
logger = log.setup_custom_logger('root')


class Converter(object):

    def __init__(self, input_format, output_format):
        self.input_format = input_format
        self.output_format = output_format
        self.plugins = self.get_available_plugins()
        self.graph = self.create_graph()
        self.check_formats()

    @staticmethod
    def get_available_plugins():
        """Look for all the doconv plugins installed and return only the ones
        having all their dependencies present in the system.
        """
        mgr = extension.ExtensionManager(
            namespace='doconv.converter',
            invoke_on_load=True,
            propagate_map_exceptions=True,
        )

        # only plugins whose dependencies are installed will be used
        plugins = []
        for plugin in mgr:
            try:
                plugin.obj.check_dependencies()
                plugins.append(plugin)
                logger.debug("Plugin {0} has been loaded".format(plugin.name))
                # TODO. Create specific exception
            except UnsatisfiedDependencyException as e:
                logger.warn(
                    "Plugin {0} could not be loaded because of missing" \
                    "dependencies: {1}".format(plugin.name, e))
        return plugins

    def get_plugin(self, name):
        """Returns an instance of the required plugin based on its name.
        Return None if not found.
        """
        plugin_found = None
        for plugin in self.plugins:
            if plugin.name == name:
                plugin_found = plugin.obj
        return plugin_found

    def create_graph(self):
        """Composes the graphs of the different plugins into a single graph.
        """

        # create conversion graph based on loaded plugins
        plugin_graphs = []
        for plugin in self.plugins:
            plugin_graphs.append(plugin.obj.get_supported_conversions_graph())

        joined_graph = nx.MultiDiGraph()
        for graph in plugin_graphs:
            joined_graph.add_edges_from(graph.edges(data=True))
        return joined_graph

    def execute_plugin_chain(self, input_file, plugin_chain):
        """ Calls each plugin in the needed order feeding as input file
        the output file generated by the plugin previously called.
        """
        files_to_remove = []
        output_file = None

        for plugin_tuple in plugin_chain:
            plugin = self.get_plugin(plugin_tuple.plugin)

            tmp_output_filename = append_random_suffix(input_file)
            output_file = plugin.convert(input_file, plugin_tuple.input_format,
                                         plugin_tuple.output_format,
                                         tmp_output_filename)

            input_file = output_file
            files_to_remove.append(output_file)
        files_to_remove = files_to_remove[:-1]
        for document in files_to_remove:
            os.remove(document)
        return output_file

    def get_plugin_by_formats(self, input_format, output_format):
        """Return the plugin with highest priority able to convert from
        input_format to output_format.
        """
        available_plugins = self.graph[input_format][output_format]
        plugins_unsorted = [k for k in available_plugins.values()]
        plugins_by_priority = sorted(
            plugins_unsorted, key=lambda k: k['priority'], reverse=True)
        plugin = plugins_by_priority[0]['plugin']
        return plugin

    def get_plugin_chain(self):
        """Following the graph_path creates an ordered list of the plugins to
        be called and the input and output format to be used with each plugin.
        """
        plugin_chain = []
        Conversion = namedtuple(
            'conversion', 'plugin input_format output_format')

        conversion_path = self.choose_best_conversion_path()

        for node_pos in range(len(conversion_path) - 1):
            input_format = conversion_path[node_pos]
            output_format = conversion_path[node_pos + 1]
            plugin = self.get_plugin_by_formats(input_format, output_format)
            plugin_chain.extend(
                [Conversion(plugin, input_format, output_format)])

        logger.debug(
            "Plugins used for each transformation: {0}".format(plugin_chain))
        return plugin_chain

    def choose_best_conversion_path(self):
        """Select as path the one that requires less conversions.
        """
        try:
            conversion_path = nx.shortest_path(
                self.graph, self.input_format, self.output_format)
        except nx.NetworkXNoPath:
            raise Exception("""
            No combination of plugins available in doconv can convert from
            {0} to {1}""".format(self.input_format, self.output_format))

        conversion_path = conversion_path if self.graph is not None else None
        logger.debug(
            "Chosen chain of transformations: {0}".format(conversion_path))
        return conversion_path

    def check_formats(self):

        logger.debug("Supported formats: {0}".format(self.graph.nodes()))
        logger.debug(
            "Supported format conversions: {0}".format(self.graph.edges()))

        if self.input_format not in self.graph.nodes():
            raise Exception("Error: Not supported input format: {0}".
                            format(self.input_format))
        if self.output_format not in self.graph.nodes():
            raise Exception("Error: Not supported output format: {0}".
                            format(self.output_format))
        if self.input_format == self.output_format:
            raise Exception("Error: Same input and output formats specified")

    def convert(self, input_file, output_file=None):

        plugin_chain = self.get_plugin_chain()
        tmp_output_file = self.execute_plugin_chain(input_file, plugin_chain)

        if output_file is None:
            final_output_file_no_ext = path.splitext(
                path.basename(tmp_output_file))[0]
            output_file = final_output_file_no_ext + '.' + self.output_format
        shutil.move(tmp_output_file, output_file)
        print(
            "Conversion successful: file {0} generated".format(output_file))
        return output_file


def main():
    # parse CLI arguments
    arguments = docopt(__doc__, version='doconv ' + get_version())
    input_format = arguments['<input_format>']
    output_format = arguments['<output_format>']
    input_file = arguments['<file>']
    output_file = arguments['--out-file']
    verbose = arguments['--verbose']

    if verbose:
        logger.setLevel(logging.DEBUG)

    try:
        converter = Converter(input_format, output_format)
        input_file_path = path.abspath(input_file)

        if output_file:
            output_file_path = path.abspath(output_file)
            converter.convert(input_file_path, output_file_path)
        else:
            converter.convert(input_file_path)
    except Exception as e:
        if not verbose:
            print(e)
        else:
            logger.exception(e)

        sys.exit(1)


if __name__ == '__main__':
    main()
